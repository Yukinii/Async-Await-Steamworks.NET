// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2015 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

using System.Runtime.InteropServices;

namespace Steamworks {
	public static class SteamGameServerUGC {
		/// <summary>
		/// <para> Query UGC associated with a user. Creator app id or consumer app id must be valid and be set to the current running app. unPage should start at 1.</para>
		/// </summary>
		public static UGCQueryHandle CreateQueryUserUGCRequest(AccountId accountId, UserUGCList listType, MatchingUGCType eMatchingUGCType, UGCListSortOrder eSortOrder, AppId nCreatorAppID, AppId nConsumerAppID, uint unPage) {
			InteropHelp.TestIfAvailableGameServer();
			return (UGCQueryHandle)NativeMethods.ISteamGameServerUGC_CreateQueryUserUGCRequest(accountId, listType, eMatchingUGCType, eSortOrder, nCreatorAppID, nConsumerAppID, unPage);
		}

		/// <summary>
		/// <para> Query for all matching UGC. Creator app id or consumer app id must be valid and be set to the current running app. unPage should start at 1.</para>
		/// </summary>
		public static UGCQueryHandle CreateQueryAllUGCRequest(UGCQuery eQueryType, MatchingUGCType eMatchingeMatchingUGCTypeFileType, AppId nCreatorAppID, AppId nConsumerAppID, uint unPage) {
			InteropHelp.TestIfAvailableGameServer();
			return (UGCQueryHandle)NativeMethods.ISteamGameServerUGC_CreateQueryAllUGCRequest(eQueryType, eMatchingeMatchingUGCTypeFileType, nCreatorAppID, nConsumerAppID, unPage);
		}

		/// <summary>
		/// <para> Query for the details of the given published file ids (the RequestUGCDetails call is deprecated and replaced with this)</para>
		/// </summary>
		public static UGCQueryHandle CreateQueryUGCDetailsRequest(PublishedFileId[] PublishedFileID, uint unNumPublishedFileIDs) {
			InteropHelp.TestIfAvailableGameServer();
			return (UGCQueryHandle)NativeMethods.ISteamGameServerUGC_CreateQueryUGCDetailsRequest(PublishedFileID, unNumPublishedFileIDs);
		}

		/// <summary>
		/// <para> Send the query to Steam</para>
		/// </summary>
		public static SteamAPICall SendQueryUGCRequest(UGCQueryHandle handle) {
			InteropHelp.TestIfAvailableGameServer();
			return (SteamAPICall)NativeMethods.ISteamGameServerUGC_SendQueryUGCRequest(handle);
		}

		/// <summary>
		/// <para> Retrieve an individual result after receiving the callback for querying UGC</para>
		/// </summary>
		public static bool GetQueryUGCResult(UGCQueryHandle handle, uint index, out SteamUGCDetails pDetails) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_GetQueryUGCResult(handle, index, out pDetails);
		}

		public static bool GetQueryUGCPreviewURL(UGCQueryHandle handle, uint index, out string URL, uint URLSize) {
			InteropHelp.TestIfAvailableGameServer();
			var URL2 = Marshal.AllocHGlobal((int)URLSize);
			var ret = NativeMethods.ISteamGameServerUGC_GetQueryUGCPreviewURL(handle, index, URL2, URLSize);
			URL = ret ? InteropHelp.PtrToStringUTF8(URL2) : null;
			Marshal.FreeHGlobal(URL2);
			return ret;
		}

		public static bool GetQueryUGCMetadata(UGCQueryHandle handle, uint index, out string Metadata, uint Metadatasize) {
			InteropHelp.TestIfAvailableGameServer();
			var Metadata2 = Marshal.AllocHGlobal((int)Metadatasize);
			var ret = NativeMethods.ISteamGameServerUGC_GetQueryUGCMetadata(handle, index, Metadata2, Metadatasize);
			Metadata = ret ? InteropHelp.PtrToStringUTF8(Metadata2) : null;
			Marshal.FreeHGlobal(Metadata2);
			return ret;
		}

		public static bool GetQueryUGCChildren(UGCQueryHandle handle, uint index, PublishedFileId[] PublishedFileID, uint cMaxEntries) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_GetQueryUGCChildren(handle, index, PublishedFileID, cMaxEntries);
		}

		public static bool GetQueryUGCStatistic(UGCQueryHandle handle, uint index, EItemStatistic eStatType, out uint pStatValue) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_GetQueryUGCStatistic(handle, index, eStatType, out pStatValue);
		}

		public static uint GetQueryUGCNumAdditionalPreviews(UGCQueryHandle handle, uint index) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_GetQueryUGCNumAdditionalPreviews(handle, index);
		}

		public static bool GetQueryUGCAdditionalPreview(UGCQueryHandle handle, uint index, uint previewIndex, out string URLOrVideoID, uint URLSize, out bool pbIsImage) {
			InteropHelp.TestIfAvailableGameServer();
			var URLOrVideoID2 = Marshal.AllocHGlobal((int)URLSize);
			var ret = NativeMethods.ISteamGameServerUGC_GetQueryUGCAdditionalPreview(handle, index, previewIndex, URLOrVideoID2, URLSize, out pbIsImage);
			URLOrVideoID = ret ? InteropHelp.PtrToStringUTF8(URLOrVideoID2) : null;
			Marshal.FreeHGlobal(URLOrVideoID2);
			return ret;
		}

		public static uint GetQueryUGCNumKeyValueTags(UGCQueryHandle handle, uint index) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_GetQueryUGCNumKeyValueTags(handle, index);
		}

		public static bool GetQueryUGCKeyValueTag(UGCQueryHandle handle, uint index, uint keyValueTagIndex, out string Key, uint KeySize, out string Value, uint ValueSize) {
			InteropHelp.TestIfAvailableGameServer();
			var Key2 = Marshal.AllocHGlobal((int)KeySize);
			var Value2 = Marshal.AllocHGlobal((int)ValueSize);
			var ret = NativeMethods.ISteamGameServerUGC_GetQueryUGCKeyValueTag(handle, index, keyValueTagIndex, Key2, KeySize, Value2, ValueSize);
			Key = ret ? InteropHelp.PtrToStringUTF8(Key2) : null;
			Marshal.FreeHGlobal(Key2);
			Value = ret ? InteropHelp.PtrToStringUTF8(Value2) : null;
			Marshal.FreeHGlobal(Value2);
			return ret;
		}

		/// <summary>
		/// <para> Release the request to free up memory, after retrieving results</para>
		/// </summary>
		public static bool ReleaseQueryUGCRequest(UGCQueryHandle handle) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_ReleaseQueryUGCRequest(handle);
		}

		/// <summary>
		/// <para> Options to set for querying UGC</para>
		/// </summary>
		public static bool AddRequiredTag(UGCQueryHandle handle, string pTagName) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pTagName2 = new InteropHelp.UTF8StringHandle(pTagName)) {
				return NativeMethods.ISteamGameServerUGC_AddRequiredTag(handle, pTagName2);
			}
		}

		public static bool AddExcludedTag(UGCQueryHandle handle, string pTagName) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pTagName2 = new InteropHelp.UTF8StringHandle(pTagName)) {
				return NativeMethods.ISteamGameServerUGC_AddExcludedTag(handle, pTagName2);
			}
		}

		public static bool SetReturnKeyValueTags(UGCQueryHandle handle, bool bReturnKeyValueTags) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_SetReturnKeyValueTags(handle, bReturnKeyValueTags);
		}

		public static bool SetReturnLongDescription(UGCQueryHandle handle, bool bReturnLongDescription) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_SetReturnLongDescription(handle, bReturnLongDescription);
		}

		public static bool SetReturnMetadata(UGCQueryHandle handle, bool bReturnMetadata) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_SetReturnMetadata(handle, bReturnMetadata);
		}

		public static bool SetReturnChildren(UGCQueryHandle handle, bool bReturnChildren) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_SetReturnChildren(handle, bReturnChildren);
		}

		public static bool SetReturnAdditionalPreviews(UGCQueryHandle handle, bool bReturnAdditionalPreviews) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_SetReturnAdditionalPreviews(handle, bReturnAdditionalPreviews);
		}

		public static bool SetReturnTotalOnly(UGCQueryHandle handle, bool bReturnTotalOnly) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_SetReturnTotalOnly(handle, bReturnTotalOnly);
		}

		public static bool SetLanguage(UGCQueryHandle handle, string Language) {
			InteropHelp.TestIfAvailableGameServer();
			using (var Language2 = new InteropHelp.UTF8StringHandle(Language)) {
				return NativeMethods.ISteamGameServerUGC_SetLanguage(handle, Language2);
			}
		}

		public static bool SetAllowCachedResponse(UGCQueryHandle handle, uint unMaxAgeSeconds) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_SetAllowCachedResponse(handle, unMaxAgeSeconds);
		}

		/// <summary>
		/// <para> Options only for querying user UGC</para>
		/// </summary>
		public static bool SetCloudFileNameFilter(UGCQueryHandle handle, string pMatchCloudFileName) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pMatchCloudFileName2 = new InteropHelp.UTF8StringHandle(pMatchCloudFileName)) {
				return NativeMethods.ISteamGameServerUGC_SetCloudFileNameFilter(handle, pMatchCloudFileName2);
			}
		}

		/// <summary>
		/// <para> Options only for querying all UGC</para>
		/// </summary>
		public static bool SetMatchAnyTag(UGCQueryHandle handle, bool bMatchAnyTag) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_SetMatchAnyTag(handle, bMatchAnyTag);
		}

		public static bool SetSearchText(UGCQueryHandle handle, string pSearchText) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pSearchText2 = new InteropHelp.UTF8StringHandle(pSearchText)) {
				return NativeMethods.ISteamGameServerUGC_SetSearchText(handle, pSearchText2);
			}
		}

		public static bool SetRankedByTrendDays(UGCQueryHandle handle, uint unDays) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_SetRankedByTrendDays(handle, unDays);
		}

		public static bool AddRequiredKeyValueTag(UGCQueryHandle handle, string pKey, string pValue) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pKey2 = new InteropHelp.UTF8StringHandle(pKey))
			using (var pValue2 = new InteropHelp.UTF8StringHandle(pValue)) {
				return NativeMethods.ISteamGameServerUGC_AddRequiredKeyValueTag(handle, pKey2, pValue2);
			}
		}

		/// <summary>
		/// <para> DEPRECATED - Use CreateQueryUGCDetailsRequest call above instead!</para>
		/// </summary>
		public static SteamAPICall RequestUGCDetails(PublishedFileId fileId, uint unMaxAgeSeconds) {
			InteropHelp.TestIfAvailableGameServer();
			return (SteamAPICall)NativeMethods.ISteamGameServerUGC_RequestUGCDetails(fileId, unMaxAgeSeconds);
		}

		/// <summary>
		/// <para> Steam Workshop Creator API</para>
		/// <para> create new item for this app with no content attached yet</para>
		/// </summary>
		public static SteamAPICall CreateItem(AppId nConsumerAppId, WorkshopFileType fileType) {
			InteropHelp.TestIfAvailableGameServer();
			return (SteamAPICall)NativeMethods.ISteamGameServerUGC_CreateItem(nConsumerAppId, fileType);
		}

		/// <summary>
		/// <para> start an UGC item update. Set changed properties before commiting update with CommitItemUpdate()</para>
		/// </summary>
		public static UGCUpdateHandle StartItemUpdate(AppId nConsumerAppId, PublishedFileId fileId) {
			InteropHelp.TestIfAvailableGameServer();
			return (UGCUpdateHandle)NativeMethods.ISteamGameServerUGC_StartItemUpdate(nConsumerAppId, fileId);
		}

		/// <summary>
		/// <para> change the title of an UGC item</para>
		/// </summary>
		public static bool SetItemTitle(UGCUpdateHandle handle, string Title) {
			InteropHelp.TestIfAvailableGameServer();
			using (var Title2 = new InteropHelp.UTF8StringHandle(Title)) {
				return NativeMethods.ISteamGameServerUGC_SetItemTitle(handle, Title2);
			}
		}

		/// <summary>
		/// <para> change the description of an UGC item</para>
		/// </summary>
		public static bool SetItemDescription(UGCUpdateHandle handle, string Description) {
			InteropHelp.TestIfAvailableGameServer();
			using (var Description2 = new InteropHelp.UTF8StringHandle(Description)) {
				return NativeMethods.ISteamGameServerUGC_SetItemDescription(handle, Description2);
			}
		}

		/// <summary>
		/// <para> specify the language of the title or description that will be set</para>
		/// </summary>
		public static bool SetItemUpdateLanguage(UGCUpdateHandle handle, string Language) {
			InteropHelp.TestIfAvailableGameServer();
			using (var Language2 = new InteropHelp.UTF8StringHandle(Language)) {
				return NativeMethods.ISteamGameServerUGC_SetItemUpdateLanguage(handle, Language2);
			}
		}

		/// <summary>
		/// <para> change the metadata of an UGC item (max = DeveloperMetadataMax)</para>
		/// </summary>
		public static bool SetItemMetadata(UGCUpdateHandle handle, string MetaData) {
			InteropHelp.TestIfAvailableGameServer();
			using (var MetaData2 = new InteropHelp.UTF8StringHandle(MetaData)) {
				return NativeMethods.ISteamGameServerUGC_SetItemMetadata(handle, MetaData2);
			}
		}

		/// <summary>
		/// <para> change the visibility of an UGC item</para>
		/// </summary>
		public static bool SetItemVisibility(UGCUpdateHandle handle, Visibility eVisibility) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_SetItemVisibility(handle, eVisibility);
		}

		/// <summary>
		/// <para> change the tags of an UGC item</para>
		/// </summary>
		public static bool SetItemTags(UGCUpdateHandle updateHandle, System.Collections.Generic.IList<string> pTags) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_SetItemTags(updateHandle, new InteropHelp.SteamParamStringArray(pTags));
		}

		/// <summary>
		/// <para> update item content from this local folder</para>
		/// </summary>
		public static bool SetItemContent(UGCUpdateHandle handle, string pszContentFolder) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pszContentFolder2 = new InteropHelp.UTF8StringHandle(pszContentFolder)) {
				return NativeMethods.ISteamGameServerUGC_SetItemContent(handle, pszContentFolder2);
			}
		}

		/// <summary>
		/// <para>  change preview image file for this item. pszPreviewFile points to local image file, which must be under 1MB in size</para>
		/// </summary>
		public static bool SetItemPreview(UGCUpdateHandle handle, string pszPreviewFile) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pszPreviewFile2 = new InteropHelp.UTF8StringHandle(pszPreviewFile)) {
				return NativeMethods.ISteamGameServerUGC_SetItemPreview(handle, pszPreviewFile2);
			}
		}

		/// <summary>
		/// <para> remove any existing key-value tags with the specified key</para>
		/// </summary>
		public static bool RemoveItemKeyValueTags(UGCUpdateHandle handle, string Key) {
			InteropHelp.TestIfAvailableGameServer();
			using (var Key2 = new InteropHelp.UTF8StringHandle(Key)) {
				return NativeMethods.ISteamGameServerUGC_RemoveItemKeyValueTags(handle, Key2);
			}
		}

		/// <summary>
		/// <para> add new key-value tags for the item. Note that there can be multiple values for a tag.</para>
		/// </summary>
		public static bool AddItemKeyValueTag(UGCUpdateHandle handle, string Key, string Value) {
			InteropHelp.TestIfAvailableGameServer();
			using (var Key2 = new InteropHelp.UTF8StringHandle(Key))
			using (var Value2 = new InteropHelp.UTF8StringHandle(Value)) {
				return NativeMethods.ISteamGameServerUGC_AddItemKeyValueTag(handle, Key2, Value2);
			}
		}

		/// <summary>
		/// <para> commit update process started with StartItemUpdate()</para>
		/// </summary>
		public static SteamAPICall SubmitItemUpdate(UGCUpdateHandle handle, string ChangeNote) {
			InteropHelp.TestIfAvailableGameServer();
			using (var ChangeNote2 = new InteropHelp.UTF8StringHandle(ChangeNote)) {
				return (SteamAPICall)NativeMethods.ISteamGameServerUGC_SubmitItemUpdate(handle, ChangeNote2);
			}
		}

		public static EItemUpdateStatus GetItemUpdateProgress(UGCUpdateHandle handle, out ulong punBytesProcessed, out ulong punBytesTotal) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_GetItemUpdateProgress(handle, out punBytesProcessed, out punBytesTotal);
		}

		/// <summary>
		/// <para> Steam Workshop Consumer API</para>
		/// </summary>
		public static SteamAPICall SetUserItemVote(PublishedFileId fileId, bool bVoteUp) {
			InteropHelp.TestIfAvailableGameServer();
			return (SteamAPICall)NativeMethods.ISteamGameServerUGC_SetUserItemVote(fileId, bVoteUp);
		}

		public static SteamAPICall GetUserItemVote(PublishedFileId fileId) {
			InteropHelp.TestIfAvailableGameServer();
			return (SteamAPICall)NativeMethods.ISteamGameServerUGC_GetUserItemVote(fileId);
		}

		public static SteamAPICall AddItemToFavorites(AppId nAppId, PublishedFileId fileId) {
			InteropHelp.TestIfAvailableGameServer();
			return (SteamAPICall)NativeMethods.ISteamGameServerUGC_AddItemToFavorites(nAppId, fileId);
		}

		public static SteamAPICall RemoveItemFromFavorites(AppId nAppId, PublishedFileId fileId) {
			InteropHelp.TestIfAvailableGameServer();
			return (SteamAPICall)NativeMethods.ISteamGameServerUGC_RemoveItemFromFavorites(nAppId, fileId);
		}

		/// <summary>
		/// <para> subscribe to this item, will be installed ASAP</para>
		/// </summary>
		public static SteamAPICall SubscribeItem(PublishedFileId fileId) {
			InteropHelp.TestIfAvailableGameServer();
			return (SteamAPICall)NativeMethods.ISteamGameServerUGC_SubscribeItem(fileId);
		}

		/// <summary>
		/// <para> unsubscribe from this item, will be uninstalled after game quits</para>
		/// </summary>
		public static SteamAPICall UnsubscribeItem(PublishedFileId fileId) {
			InteropHelp.TestIfAvailableGameServer();
			return (SteamAPICall)NativeMethods.ISteamGameServerUGC_UnsubscribeItem(fileId);
		}

		/// <summary>
		/// <para> number of subscribed items</para>
		/// </summary>
		public static uint GetNumSubscribedItems() {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_GetNumSubscribedItems();
		}

		/// <summary>
		/// <para> all subscribed item PublishFileIDs</para>
		/// </summary>
		public static uint GetSubscribedItems(PublishedFileId[] PublishedFileID, uint cMaxEntries) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_GetSubscribedItems(PublishedFileID, cMaxEntries);
		}

		/// <summary>
		/// <para> get ItemState flags about item on this client</para>
		/// </summary>
		public static uint GetItemState(PublishedFileId fileId) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_GetItemState(fileId);
		}

		/// <summary>
		/// <para> get info about currently installed content on disc for items that have EItemStateInstalled set</para>
		/// <para> if EItemStateLegacyItem is set, Folder contains the path to the legacy file itself (not a folder)</para>
		/// </summary>
		public static bool GetItemInstallInfo(PublishedFileId fileId, out ulong punSizeOnDisk, out string Folder, uint FolderSize, out uint punTimeStamp) {
			InteropHelp.TestIfAvailableGameServer();
			var Folder2 = Marshal.AllocHGlobal((int)FolderSize);
			var ret = NativeMethods.ISteamGameServerUGC_GetItemInstallInfo(fileId, out punSizeOnDisk, Folder2, FolderSize, out punTimeStamp);
			Folder = ret ? InteropHelp.PtrToStringUTF8(Folder2) : null;
			Marshal.FreeHGlobal(Folder2);
			return ret;
		}

		/// <summary>
		/// <para> get info about pending update for items that have EItemStateNeedsUpdate set. punBytesTotal will be valid after download started once</para>
		/// </summary>
		public static bool GetItemDownloadInfo(PublishedFileId fileId, out ulong punBytesDownloaded, out ulong punBytesTotal) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_GetItemDownloadInfo(fileId, out punBytesDownloaded, out punBytesTotal);
		}

		/// <summary>
		/// <para> download new or update already installed item. If function returns true, wait for DownloadItemResult. If the item is already installed,</para>
		/// <para> then files on disk should not be used until callback received. If item is not subscribed to, it will be cached for some time.</para>
		/// <para> If bHighPriority is set, any other item download will be suspended and this item downloaded ASAP.</para>
		/// </summary>
		public static bool DownloadItem(PublishedFileId fileId, bool bHighPriority) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServerUGC_DownloadItem(fileId, bHighPriority);
		}

		/// <summary>
		/// <para> game servers can set a specific workshop folder before issuing any UGC commands.</para>
		/// <para> This is helpful if you want to support multiple game servers running out of the same install folder</para>
		/// </summary>
		public static bool BInitWorkshopForGameServer(DepotId unWorkshopDepotID, string pszFolder) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pszFolder2 = new InteropHelp.UTF8StringHandle(pszFolder)) {
				return NativeMethods.ISteamGameServerUGC_BInitWorkshopForGameServer(unWorkshopDepotID, pszFolder2);
			}
		}

		/// <summary>
		/// <para> SuspendDownloads( true ) will suspend all workshop downloads until SuspendDownloads( false ) is called or the game ends</para>
		/// </summary>
		public static void SuspendDownloads(bool bSuspend) {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamGameServerUGC_SuspendDownloads(bSuspend);
		}
	}
}